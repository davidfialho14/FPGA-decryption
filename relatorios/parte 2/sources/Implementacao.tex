\section{Implementação}

\subsection{Características do Hardware}

\subsubsection{Dimensionamento} 

\paragraph{} Nesta segunda implementação fez-se um esforço de forma a tentar reduzir o tamanho do programa com o objectivo poder colocar tanto o programa como os dados e o \textit{stack} respectivos na memória local de cada processador. Se isto não fosse possível era necessário garantir que o espaço de programa, dados e \textit{stack} de cada um dos processadores não se sobrepunham, desta forma este requisito é explicitamente garantido. Além de preencher este requisito a utilização das memórias locais permitiu acelerar a execução do programa em aproximadamente 10 vezes.

Foi feita uma estimativa do tamanho necessário para o \textit{stack} tendo em conta as funções chamadas durante a execução da aplicação e concluiu-se que é necessário um \textit{stack} com, aproximadamente, 2KB.

Tendo em conta o tamanho do \textit{stack} e dado que o programa em cada um dos processadores tem um tamanho de, aproximadamente, 20KB foi necessária a utilização de memórias locais de 32 KB.

O \textit{master} tem um tamanho de programa algo superior aos outros processadores (24KB), isto deve-se principalmente à utilização do \textit{"xil\_printf"}, mas além desta função este inclui algum código extra para assegurar a sincronização e a contagem do tempo. A função \textit{"xil\_printf"} é utilizada apenas como método para imprimir o tempo de execução e o resultado da computação, desta forma numa aplicação final este não é utilizado e por isso pode considerar-se que o tamanho de programa do \textit{master} é essencialmente igual ao de todos os outros processadores.

A memória externa mantém-se ligada ao \textit{microblaze} através de uma cache. Nesta segunda parte, dado que o programa se encontra armazenado em memória local a cache de instruções nunca é utilizada, sendo assim optou-se pela sua desactivação (na realidade não é possível desactivar, pelo que foi escolhido o tamanho mínimo). Dada a natureza da aplicação, verificou-se que uma vez que um bloco de 16 bytes era lido da memória, processado e nunca mais era acedido. Logo, a cache de dados de cada um dos processadores precisa apenas de ter capacidade para armazenar o conteúdo de um bloco inteiro de 16 bytes, após o processamento do bloco em cache este pode ser substituído pelo próximo bloco a processar uma vez que não volta a ser acedido. Definiu-se assim a cache de dados com a capacidade mínima de 64 bytes.

Além deste detalhe da aplicação, também se teve em conta que durante o processamento do bloco eram feitas várias escritas no espaço de memória correspondente a esse bloco. O ideal seria ter uma situação em que o bloco era carregado integralmente, processado (escrito) sempre em cache e quando finalmente o bloco se encontrasse no seu estado final este era escrito para a memória externa e o próximo bloco era carregado para a cache no seu lugar. Para conseguir obter este funcionamento definiu-se o método \textit{write-back} como método de escrita da cache de dados. Este método permite obter o funcionamento pretendido uma vez que os dados só são escritos na memória externa quando o bloco é substituído na cache. Este funcionamento permite reduzir o número de acessos à memória por parte de cada processador que é um dos factores mais limitativos da implementação.

Foram utilizados 4 processadores na implementação desta aplicação. O número de processadores utilizado foi escolhido com base nos resultados obtidos com um número variado de processadores e tendo em conta as limitações da FPGA disponibilizada no laboratório.

Para implementar a sincronização foi necessária a utilização de uma memória interna partilhada por todos o processadores através do barramento AXI-lite. Esta a memória é utilizada apenas para realizar a sincronização entre os vários processadores de acordo com o descrito na sub-secção de Sincronização da Arquitectura de Paralelização. Desta forma o acesso a esta memória é feito a partir do barramento AXI-lite para não interferir com o acesso ao barramento AXI-full utilizado para aceder à memória externa durante o processamento dos blocos.

\subsubsection{Limitações} 

Uma das maiores limitações na utilização de múltiplos processadores deve-se ao acesso aos vários recursos partilhados. Na implementação realizada existem dois recursos partilhados: a memória interna e a memória externa. O recurso cujo o acesso é mais frequente e que apresenta uma maior limitação no desempenho da aplicação é a memória externa. Esta é acedida por todos os processadores sempre que cada um deste termina o processamento de um bloco e inicia o processamento do bloco seguinte. Este acesso é muito frequente uma vez que o processamento de cada bloco a relativamente rápido quando comparado com o tempo de acesso à memória externa para obter o bloco a processar.

Temos assim um acesso de N processadores para 1 recurso (memória externa). Tendo em conta que o barramento AXI permite que seja lido um bloco de 4 bytes em cada acesso à memória, para obter um bloco de 16 bytes cada processador tem que fazer 4 acessos à memória externa. Vê-se assim que o número de acessos à memória pode ser elevado e cresce linearmente com o número de blocos de 16 bytes a processar.

Com a utilização de apenas um processador não é necessário recurso a um árbitro e por isso o acesso à memória é directo e não exige lógica adicional. Com a utilização de dois processadores a concorrência no acesso à memória exige a utilização de um árbitro para discernir entre os dois processadores qual é que deve aceder ao recurso em cada instante. Um componente adicional entre o processador e a memória introduz \textit{delay} de arbitragem adicional que cresce com a introdução de um maior número de processadores. Assim espera-se que o \textit{speedup} esteja de acordo com o número de processadores até um certo ponto, a partir desse ponto o \textit{speedup} começará a descer até que para um número muito elevado de processadores o \textit{speedup} poderá ser menor do que 1.

\subsection{Características do Software}
\paragraph{}
O software foi implementado de forma a ser escalável para um qualquer número processadores possíveis. Assim sendo, para que o código utilizado com 4 processadores funcione para um número X de processadores basta indicar o número X de processadores que se pretende utilizar. No nosso caso isto é feito através de um define e por isso o programa tem que ser recompilado. Em certas aplicações o custo de recompilação pode ser elevado, por isso nesses casos o ideal seria ter uma forma de indicar o número de processadores em tempo de execução. Isto seria relativamente simples de implementar introduzindo alguma mecanismo de input no sistema. No entanto pensa-se que esta não seja uma grande preocupação no desenvolvimento deste tipo de sistemas uma vez que esta recompilação só tem que ser feita quando se pretende fazer alterações ao hardware e estas têm um custo temporal substancialmente mais elevado e não são comuns.

